<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>permutations_and_combinations_2</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" />
</head>
<body>
<h1 class="unnumbered" id="permutations-and-combinations">Permutations
and combinations</h1>
<p><strong>Question.</strong> How many unique ways are there to arrange
the letters in the word [[WORD]]?</p>
<p><strong>Answer.</strong> [[ANSWER]]</p>
<p><strong>Hints.</strong></p>
<ul>
<li><p>Let’s try building the arrangements (or permutations) letter by
letter. The word is [[WORD.length]] letters long:
[[_.map(_.range(WORD.length), function(l){ return "_ "; }).join("")]]
Now, for the first blank, we have [[WORD.length]] choices of letters to
put in.</p></li>
<li><p>After we put in the first letter, let’s say it’s [[PERM[0]]], we
have [[WORD.length-1]] blanks left. [[PERM[0]+"
"+_.map(_.range(WORD.length-1), function(l){ return "_ "; }).join("")]]
For the second blank, we only have [[WORD.length-1]] choices of letters
left to put in. So far, there were [[WORD.length]] <span
class="math inline">\cdot</span> [[WORD.length-1]] unique choices we
could have made.</p></li>
<li><p>We can continue in this fashion to put in a third letter, then a
fourth, and so on. At each step, we have one fewer choice to make, until
we get to the last letter, and there’s only one we can put in.</p></li>
<li><p>Using this method, the total number of arrangements is
[[_.map(_.range(WORD.length).reverse(), function(l){ return
(++l);}).join("\{}<span class="math inline">\cdot</span>")]] =
[[factorial(WORD.length)]]. Another way of writing this is
[[WORD.length]]!, or [[WORD.length]] factorial, but this isn’t quite the
right answer.</p></li>
<li><p>Using the above method, we assumed that all the letters were
unique. But they’re not! There are [[REPTIMES]] [[REPLETTER]]s, so we’re
counting every permutation multiple times. So every time we have these
[[factorial(REPTIMES)]] permutations:</p>
<p>[[PERM_UNIQUE.join("&lt;/br&gt;")]]</p>
<p>We actually should have only one permutation:</p>
<p>[[PERM]]</p></li>
<li><p>Notice that we’ve overcounted our arrangements by [[REPTIMES]]!.
This is not a coincidence! This is exactly the number of ways to permute
[[REPTIMES]] objects, which we were doing with the non-unique
[[REPLETTER]]s. To address this overcounting, we need to divide the
number of arrangements we counted before by [[REPTIMES]]!.</p></li>
<li><p>When we divide the number of permutations we got by the number of
times we’re overcounting each permutation, we get <span
class="math inline">\frac{[[WORD.length]]!}{[[REPTIMES]]!}</span> =
<span
class="math inline">\frac{[[factorial(WORD.length)]]}{[[factorial(REPTIMES)]]}</span>
= [[ANSWER]]</p></li>
<li><p>Forget about the reindeer that can’t be together for a second,
and let’s try to figure out how many ways we can arrange the reindeer if
we don’t have to worry about that.Forget about the reindeer that have to
be together for a second, and let’s try to figure out how many ways we
can arrange the reindeer if we don’t have to worry about that. We can
build our line of reindeer one by one: there are [[NAMES.length]] slots,
and we have [[NAMES.length]] different reindeer we can put in the first
slot.</p></li>
<li><p>Once we fill the first slot, we only have [[NAMES.length-1]]
reindeer left, so we only have [[NAMES.length-1]] choices for the second
slot. So far, there are [[NAMES.length]] <span
class="math inline">\cdot</span> [[NAMES.length-1]] =
[[NAMES.length*(NAMES.length-1)]] unique choices we can make.</p></li>
<li><p>We can continue in this way for the third reindeer, then the
fourth, and so on, until we reach the last slot, where we only have one
reindeer left and so we can only make one choice.</p></li>
<li><p>So, the total number of unique choices we could make to get to an
arrangement of reindeer is [[_.map(_.range(NAMES.length).reverse(),
function(l){ return (++l);}).join("\{}<span
class="math inline">\cdot</span>")]] = [[factorial(NAMES.length)]].
Another way of writing this is [[NAMES.length]]!, or [[NAMES.length]]
factorial. But we haven’t thought about the two reindeer who can’t be
together yet.</p></li>
<li><p>So, the total number of unique choices we could make to get to an
arrangement of reindeer is [[_.map(_.range(NAMES.length).reverse(),
function(l){ return (++l);}).join("\{}<span
class="math inline">\cdot</span>")]] = [[factorial(NAMES.length)]].
Another way of writing this is [[NAMES.length]]!, or [[NAMES.length]]
factorial. But we haven’t thought about the two reindeer who have to be
together yet.</p></li>
<li><p>There are [[factorial(NAMES.length)]] different arrangements of
reindeer altogether, so we just need to subtract all the arrangements
where [[PAIR[0]]] and [[PAIR[1]]] are together. How many of these are
there?</p>
<p>We can count the number of arrangements where [[PAIR[0]]] and
[[PAIR[1]]] are together by treating them as one double-reindeer. Now we
can use the same idea as before to come up with
[[_.map(_.range(NAMES.length-1).reverse(), function(l){ return
(++l);}).join("\{}<span class="math inline">\cdot</span>")]] =
[[factorial(NAMES.length-1)]] different arrangements. But that’s not
quite right.</p>
<p>Why? Because you can arrange the double-reindeer with [[PAIR[0]]] in
front or with [[PAIR[1]]] in front, and those are different
arrangements! So the actual number of arrangements with [[PAIR[0]]] and
[[PAIR[1]]] together is [[factorial(NAMES.length-1)]] <span
class="math inline">\cdot</span> 2 = [[factorial(NAMES.length-1)*2]]</p>
<p>So, subtracting the number of arrangements where [[PAIR[0]]] and
[[PAIR[1]]] are together from the total number of arrangements, we get
[[ANSWER]] arrangements of reindeer where they will fly.</p></li>
<li><p>We can count the number of arrangements where [[PAIR[0]]] and
[[PAIR[1]]] are together by treating them as one double-reindeer. Now we
can use the same idea as before to come up with
[[_.map(_.range(NAMES.length-1).reverse(), function(l){ return
(++l);}).join("\{}<span class="math inline">\cdot</span>")]] =
[[factorial(NAMES.length-1)]] different arrangements. But that’s not
quite right.</p>
<p>Why? Because you can arrange the double-reindeer with [[PAIR[0]]] in
front or with [[PAIR[1]]] in front, and those are different
arrangements! So the actual number of arrangements with [[PAIR[0]]] and
[[PAIR[1]]] together is [[factorial(NAMES.length-1)]] <span
class="math inline">\cdot</span> 2 =
[[factorial(NAMES.length-1)*2]]</p></li>
<li><p>There are [[FAC1_TIMES]] numbers divisible by [[FAC1]] between 1
and 100, and [[FAC2_TIMES]] numbers divisible by [[FAC2]] between 1 and
100. [Show me why]</p>
<p>One way to see this is to take <span
class="math inline">\frac{100}{[[FAC1]]}</span> = [[FAC1_TIMES]]</p>
<p>One way to see this is to take <span
class="math inline">\frac{100}{[[FAC1]]}</span>, which is between
[[FAC1_TIMES]] and [[FAC1_TIMES+1]]. So, starting at 0 and adding
[[FAC1]] at each step, you have to take between [[FAC1_TIMES]] and
[[FAC1_TIMES+1]] steps to get to 100. Since if you take a fraction of a
step you won’t get to a number divisible by [[FAC1]], you’ll hit
[[FAC1_TIMES]] numbers divisible by [[FAC1]] before you get to above
100. So, there are [[FAC1_TIMES]] numbers between 1 and 100 divisible by
[[FAC1]].</p>
<p>Using similar logic for the second factor, we see that <span
class="math inline">\frac{100}{[[FAC2]]}</span> = [[FAC2_TIMES]]</p>
<p>Using similar logic for the second factor, take <span
class="math inline">\frac{100}{[[FAC2]]}</span>, which is between
[[FAC2_TIMES]] and [[FAC2_TIMES+1]]. So, starting at 0 and adding
[[FAC2]] at each step, you have to take between [[FAC2_TIMES]] and
[[FAC2_TIMES+1]] steps to get to 100. Since if you take a fraction of a
step you won’t get to a number divisible by [[FAC2]], you’ll hit
[[FAC2_TIMES]] numbers divisible by [[FAC2]] before you get to above
100. So, there are [[FAC2_TIMES]] numbers between 1 and 100 divisible by
[[FAC2]].</p></li>
<li><p>So, you might think there are [[FAC1_TIMES]] + [[FAC2_TIMES]] =
[[FAC1_TIMES+FAC2_TIMES]] numbers divisible by one or the other, but
this is overcounting something.</p></li>
<li><p>We’re counting every number which is divisible by both [[FAC1]]
and [[FAC2]] twice. So, for example, [[FAC1*FAC2]] is counted once as a
number divisible by [[FAC1]], and then again as a number divisible by
[[FAC2]].</p></li>
<li><p>So, we need to count how many numbers are divisible by both
[[FAC1]] and [[FAC2]] and subtract this from what we had
before.</p></li>
<li><p>Being divisible by both [[FAC1]] and [[FAC2]] is the same thing
as being divisible by [[FAC1*FAC2]], so there is [[BOTH_TIMES]] number
between 1 and 100 divisible by both.</p></li>
<li><p>Being divisible by both [[FAC1]] and [[FAC2]] is the same thing
as being divisible by [[FAC1*FAC2]], so there are [[BOTH_TIMES]] numbers
between 1 and 100 divisible by both.</p></li>
<li><p>Subtracting, there are [[FAC1_TIMES + FAC2_TIMES]] -
[[BOTH_TIMES]] = [[FAC1_TIMES + FAC2_TIMES - BOTH_TIMES]] numbers
divisible by [[FAC1]] or [[FAC2]].</p></li>
</ul>
</body>
</html>
